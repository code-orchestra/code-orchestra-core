package jetbrains.mps.vcs.annotate;

/*Generated by MPS */

import com.intellij.openapi.vcs.annotate.FileAnnotation;
import java.util.Map;
import com.intellij.openapi.vcs.history.VcsRevisionNumber;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.intellij.openapi.vcs.history.VcsFileRevision;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.awt.FontMetrics;
import java.util.Date;

public class CommitNumberSubcolumn extends AnnotationAspectSubcolumn {
  private FileAnnotation myFileAnnotation;
  private Map<VcsRevisionNumber, Integer> myRevisionsToNumbers;

  public CommitNumberSubcolumn(AnnotationColumn annotationColumn, FileAnnotation fileAnnotation) {
    super(annotationColumn, null);
    myFileAnnotation = fileAnnotation;
  }

  @Override
  public String getTextForFileLine(int fileLine) {
    return "" + MapSequence.fromMap(myRevisionsToNumbers).get(myFileAnnotation.getLineRevisionNumber(fileLine));
  }

  private void computeNumbers(Iterable<Integer> fileLines) {
    myRevisionsToNumbers = MapSequence.fromMap(new HashMap<VcsRevisionNumber, Integer>());
    final Map<VcsRevisionNumber, VcsFileRevision> revisionNumberToRevision = MapSequence.fromMap(new HashMap<VcsRevisionNumber, VcsFileRevision>());
    for (VcsFileRevision rev : ListSequence.fromList(myFileAnnotation.getRevisions())) {
      MapSequence.fromMap(revisionNumberToRevision).put(rev.getRevisionNumber(), rev);
    }

    List<VcsRevisionNumber> revisionNumbers = SetSequence.fromSet(SetSequence.fromSetWithValues(new HashSet<VcsRevisionNumber>(), Sequence.fromIterable(fileLines).select(new ISelector<Integer, VcsRevisionNumber>() {
      public VcsRevisionNumber select(Integer fl) {
        return myFileAnnotation.getLineRevisionNumber(fl);
      }
    }))).sort(new ISelector<VcsRevisionNumber, Comparable<?>>() {
      public Comparable<?> select(VcsRevisionNumber rn) {
        return MapSequence.fromMap(revisionNumberToRevision).get(rn).getRevisionDate();
      }
    }, true).toListSequence();
    revisionNumbers = ListSequence.fromList(revisionNumbers).sort(new ISelector<VcsRevisionNumber, Comparable<?>>() {
      public Comparable<?> select(VcsRevisionNumber rn) {
        return check_efout7_a0a0a0a0f0b(MapSequence.fromMap(revisionNumberToRevision).get(rn));
      }
    }, true).toListSequence();
    for (int i = 0; i < ListSequence.fromList(revisionNumbers).count(); i++) {
      MapSequence.fromMap(myRevisionsToNumbers).put(ListSequence.fromList(revisionNumbers).getElement(i), i + 1);
    }
  }

  @Override
  public void computeWidth(FontMetrics fontMetrics, Iterable<Integer> fileLines) {
    computeNumbers(fileLines);
    super.computeWidth(fontMetrics, fileLines);
  }

  @Override
  public String getId() {
    return "Commit number";
  }

  @Override
  public boolean isRightAligned() {
    return true;
  }

  private static Date check_efout7_a0a0a0a0f0b(VcsFileRevision checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getRevisionDate();
    }
    return null;
  }
}
