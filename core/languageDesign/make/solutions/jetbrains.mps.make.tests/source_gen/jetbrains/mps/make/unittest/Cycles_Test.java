package jetbrains.mps.make.unittest;

/*Generated by MPS */

import junit.framework.TestCase;
import jetbrains.mps.internal.make.runtime.util.GraphAnalyzer;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;

public class Cycles_Test extends TestCase {
  public void test_primitive() throws Exception {
    Graph<String> graph = new Graph<String>();
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    graph.addEdges("A", "B");
    Assert.assertTrue(ListSequence.fromList(cd.findCycles()).isEmpty());
    final Queue<String> q = QueueSequence.fromQueueAndArray(new LinkedList<String>(), "A", "B");
    Sequence.fromIterable(cd.topologicalSort()).visitAll(new IVisitor<String>() {
      public void visit(String v) {
        Assert.assertEquals(QueueSequence.fromQueue(q).removeFirstElement(), v);
      }
    });
    graph.addEdges("B", "A");
    List<List<String>> cycles = cd.findCycles();
    Assert.assertSame(1, ListSequence.fromList(cycles).count());
    Assert.assertEquals(ListSequence.fromListAndArray(new ArrayList<String>(), "A", "B"), ListSequence.fromList(cycles).getElement(0));
  }

  public void test_self() throws Exception {
    Graph<String> graph = new Graph<String>();
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    graph.addEdges("A", "A");
    List<List<String>> cycles = cd.findCycles();
    Assert.assertSame(1, ListSequence.fromList(cycles).count());
    Assert.assertEquals(ListSequence.fromListAndArray(new ArrayList<String>(), "A"), ListSequence.fromList(cycles).getElement(0));
    graph.addEdges("B", "B");
    List<List<String>> cycles2 = cd.findCycles();
    Assert.assertSame(2, ListSequence.fromList(cycles2).count());
    Assert.assertTrue(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList(), ListSequence.fromListAndArray(new ArrayList<String>(), "A"), ListSequence.fromListAndArray(new ArrayList<String>(), "B"))).disjunction(ListSequence.fromList(cycles2)).isEmpty());
  }

  public void test_oneCycle() throws Exception {
    Graph<String> graph = new Graph<String>();
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    graph.addEdges("A", "B", "C");
    graph.addEdges("B", "D", "E");
    graph.addEdges("D", "C");
    graph.addEdges("C", "B", "E");
    List<List<String>> cycles = cd.findCycles();
    Assert.assertSame(1, ListSequence.fromList(cycles).count());
    Assert.assertSame(3, ListSequence.fromList(ListSequence.fromList(cycles).getElement(0)).count());
    Assert.assertTrue(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<String>(), "B", "C", "D")).disjunction(ListSequence.fromList(ListSequence.fromList(cycles).getElement(0))).isEmpty());
  }

  public void test_linear() throws Exception {
    Graph<String> graph = new Graph<String>();
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    graph.addEdges("A", "B");
    graph.addEdges("B", "C");
    graph.addEdges("C", "D");
    graph.sort(new _FunctionTypes._return_P1_E0<String, String>() {
      public String invoke(String s) {
        return s;
      }
    }, false);
    List<List<String>> cycles = cd.findCycles();
    Assert.assertSame(0, ListSequence.fromList(cycles).count());
    cycles = cd.findCycles();
    Assert.assertSame(0, ListSequence.fromList(cycles).count());
    graph.sort(new _FunctionTypes._return_P1_E0<Integer, String>() {
      public Integer invoke(String s) {
        return ((Object) s).hashCode();
      }
    }, true);
    cycles = cd.findCycles();
    Assert.assertSame(0, ListSequence.fromList(cycles).count());
  }

  public void test_fourCycles() throws Exception {
    Graph<String> graph = new Graph<String>();
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    graph.addEdges("A", "B");
    graph.addEdges("B", "C", "F", "E");
    graph.addEdges("C", "D", "G");
    graph.addEdges("D", "C", "H");
    graph.addEdges("E", "A", "F");
    graph.addEdges("F", "G");
    graph.addEdges("G", "F", "H", "I", "J");
    graph.addEdges("H", "I");
    graph.addEdges("I", "G", "K");
    List<List<String>> cycles = cd.findCycles();
    Assert.assertSame(3, ListSequence.fromList(cycles).count());
    Assert.assertTrue(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<String>(), "A", "B", "E")).disjunction(ListSequence.fromList(ListSequence.fromList(cycles).getElement(0))).isEmpty());
    Assert.assertTrue(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<String>(), "D", "C")).disjunction(ListSequence.fromList(ListSequence.fromList(cycles).getElement(1))).isEmpty());
    Assert.assertTrue(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<String>(), "G", "I", "F", "H")).disjunction(ListSequence.fromList(ListSequence.fromList(cycles).getElement(2))).isEmpty());
  }

  public void test_topoSort() throws Exception {
    Graph<String> graph = new Graph<String>();
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    graph.addEdges("A", "B", "C", "H", "I");
    graph.addEdges("B", "C", "D", "E", "G");
    graph.addEdges("C", "D", "G", "K");
    graph.addEdges("D", "E", "H");
    graph.addEdges("E", "F");
    graph.addEdges("F", "G");
    graph.addEdges("G", "H", "I", "J");
    graph.addEdges("H", "I");
    graph.addEdges("I", "K", "J");
    List<List<String>> cycles = cd.findCycles();
    Assert.assertSame(0, ListSequence.fromList(cycles).count());
    Utils.assertSameSequence(ListSequence.fromListAndArray(new ArrayList<String>(), "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"), cd.topologicalSort());
    graph.sort(new _FunctionTypes._return_P1_E0<String, String>() {
      public String invoke(String s) {
        return s;
      }
    }, false);
    Utils.assertSameSequence(ListSequence.fromListAndArray(new ArrayList<String>(), "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"), cd.topologicalSort());
  }

  public void test_precursors() throws Exception {
    Graph<String> graph = new Graph<String>();
    graph.addEdges("A", "B");
    graph.addEdges("C", "D", "E");
    graph.addEdges("D", "F");
    GraphAnalyzer<String> cd = graph.getCycleDetector();
    Utils.assertSameSequence(ListSequence.fromListAndArray(new ArrayList<String>(), "C", "E"), cd.precursors("E"));
    graph.addEdges("D", "E");
    Utils.assertSameSequence(ListSequence.fromListAndArray(new ArrayList<String>(), "C", "D", "E"), cd.precursors("E"));
    graph.addEdges("B", "C");
    graph.sort(new _FunctionTypes._return_P1_E0<String, String>() {
      public String invoke(String s) {
        return s;
      }
    }, false);
    Utils.assertSameSequence(ListSequence.fromListAndArray(new ArrayList<String>(), "A", "B", "C", "D", "E"), cd.precursors("E"));
  }
}
