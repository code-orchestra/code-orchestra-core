package jetbrains.mps.make.unittest;

/*Generated by MPS */

import jetbrains.mps.make.script.IConfig;
import jetbrains.mps.make.script.IConfigMonitor;
import jetbrains.mps.make.resources.IPropertiesAccessor;
import jetbrains.mps.make.script.IJob;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IJobMonitor;
import jetbrains.mps.make.facet.IFacet;
import org.jmock.Mockery;
import org.jmock.Expectations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.make.facet.ITarget;
import java.util.Arrays;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.make.script.IProgress;

public class Mockups {
  private static IConfig DefaultConfig = new IConfig() {
    public boolean configure(IConfigMonitor cmon, IPropertiesAccessor pa) {
      return true;
    }
  };
  private static IJob DefaultJob = new IJob() {
    public IResult execute(final Iterable<IResource> ignore, IJobMonitor mon, IPropertiesAccessor pa) {
      return DefaultResult;
    }
  };
  private static IResult DefaultResult = new IResult() {
    public boolean isSucessful() {
      return true;
    }

    public Iterable<IResource> output() {
      return null;
    }
  };

  public Mockups() {
  }

  public static IFacet facet(Mockery context, final String name) {
    final IFacet fct = context.mock(IFacet.class, name);
    context.checking(new Expectations() {
      {
        this.atLeast(2).of(fct).getName();
        this.will(returnValue(new IFacet.Name(name)));
      }
    });
    return fct;
  }

  public static void allowing(Mockery context, final IFacet fct) {
    context.checking(new Expectations() {
      {
        this.allowing(fct).extended();
        this.will(returnValue(Sequence.fromArray(new IFacet.Name[]{})));
        this.allowing(fct).required();
        this.will(returnValue(Sequence.fromArray(new IFacet.Name[]{})));
        this.allowing(fct).optional();
        this.will(returnValue(Sequence.fromArray(new IFacet.Name[]{})));
        this.allowing(fct).targets();
        this.will(returnValue(Sequence.fromArray(new ITarget[]{})));
      }
    });
  }

  public static ITarget target(Mockery context, String name) {
    return target(context, name, new ITarget.Name(name), null);
  }

  public static ITarget target(Mockery context, String name, Class[] expIn) {
    return target(context, name, new ITarget.Name(name), expIn);
  }

  public static ITarget target(Mockery context, String name, ITarget.Name tname) {
    return target(context, name, tname, null);
  }

  public static ITarget target(Mockery context, String name, final ITarget.Name tname, final Class[] expIn) {
    final ITarget trg = context.mock(ITarget.class, name);
    context.checking(new Expectations() {
      {
        this.atLeast(1).of(trg).getName();
        this.will(returnValue(tname));
      }
    });
    if (expIn != null) {
      context.checking(new Expectations() {
        {
          this.atLeast(1).of(trg).requiresInput();
          this.will(returnValue(true));

          this.atLeast(1).of(trg).expectedInput();
          this.will(returnValue(Arrays.asList(expIn)));
        }
      });

    }
    return trg;
  }

  public static void allowing(Mockery context, final ITarget trg) {
    context.checking(new Expectations() {
      {
        this.allowing(trg).before();
        this.will(returnValue(Sequence.fromArray(new ITarget.Name[]{})));
        this.allowing(trg).notBefore();
        this.will(returnValue(Sequence.fromArray(new ITarget.Name[]{})));
        this.allowing(trg).after();
        this.will(returnValue(Sequence.fromArray(new ITarget.Name[]{})));
        this.allowing(trg).notAfter();
        this.will(returnValue(Sequence.fromArray(new ITarget.Name[]{})));
        this.allowing(trg).createJob();
        this.will(returnValue(Mockups.DefaultJob));
        this.allowing(trg).createConfig();
        this.will(returnValue(Mockups.DefaultConfig));
        this.allowing(trg).requiresInput();
        this.will(returnValue(false));
        this.allowing(trg).producesOutput();
        this.will(returnValue(false));
        this.allowing(trg).expectedInput();
        this.will(returnValue(null));
        this.allowing(trg).expectedOutput();
        this.will(returnValue(null));
      }
    });
  }

  public static IJob job(Mockery context, String name) {
    final IJob job = context.mock(IJob.class, name);
    return job;
  }

  public static IJob job(Mockery context, String name, final _FunctionTypes._return_P0_E0<? extends IResult> fun) {
    final IJob job = context.mock(IJob.class, name);
    context.checking(new Expectations() {
      {
        this.exactly(1).of(job).execute(this.with(aNonNull(Iterable.class)), this.with(aNonNull(IJobMonitor.class)), this.with(aNonNull(IPropertiesAccessor.class)));
        this.will(returnValue(fun.invoke()));
      }
    });
    return job;
  }

  public static IResult result(Mockery context, String name, final boolean res) {
    final IResult result = context.mock(IResult.class, name);
    context.checking(new Expectations() {
      {
        this.atLeast(1).of(result).isSucessful();
        this.will(returnValue(res));
      }
    });
    return result;
  }

  public static void allowing(Mockery context, final IResult result) {
    context.checking(new Expectations() {
      {
        this.allowing(result).output();
        this.will(returnValue(null));
      }
    });
  }

  public static IResource resource(Mockery context, String name) {
    return context.mock(IResource.class, name);
  }

  public static IJobMonitor monitor(Mockery context, String name) {
    final IJobMonitor monitor = context.mock(IJobMonitor.class, name);
    context.checking(new Expectations() {
      {
        this.allowing(monitor).stopRequested();
        this.will(returnValue(false));
      }
    });
    return monitor;
  }

  public static IConfigMonitor cmonitor(Mockery context, String name) {
    final IConfigMonitor cmonitor = context.mock(IConfigMonitor.class, name);
    return cmonitor;
  }

  public static IScriptController monitors(Mockery context, String name) {
    final IScriptController mons = context.mock(IScriptController.class, name);
    return mons;
  }

  public static void allowing(Mockery context, final IScriptController mons) {
    context.checking(new Expectations() {
      {
        this.allowing(mons).runConfigWithMonitor((_FunctionTypes._void_P1_E0<? super IConfigMonitor>) this.with(aNonNull(Object.class)));
        this.allowing(mons).runJobWithMonitor((_FunctionTypes._void_P1_E0<? super IJobMonitor>) this.with(aNonNull(Object.class)));
      }
    });
  }

  public static void allowing(Mockery context, final IJobMonitor jmon) {
    context.checking(new Expectations() {
      {
        this.allowing(jmon).currentProgress();
        this.will(returnValue(new IProgress.Stub()));
        this.allowing(jmon).stopRequested();
        this.will(returnValue(false));
      }
    });
  }
}
